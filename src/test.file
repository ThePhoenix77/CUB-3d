mandatory:
	|_execution:
		initialize_rays.c "#include "../cub3d.h"

			float	ft_periodic(float angle)
			{
				while (angle < 0)
					angle += (2 * M_PI);
				while (angle > (2 * M_PI))
					angle -= (2 * M_PI);
				return (angle);
			}

			void	initialize_tray(t_ray *ray, float ray_angle)
			{
				ray->ray_angle = ray_angle;
				ray->wall_hit_x = 0;
				ray->wall_hit_y = 0;
				ray->distance = 0;
				if (ray_angle > 0 && ray_angle < M_PI)
					ray->ray_facing_down = 1;
				else
					ray->ray_facing_down = 0;
				if (!ray->ray_facing_down)
					ray->ray_facing_up = 1;
				else
					ray->ray_facing_up = 0;
				if (ray_angle < 0.5 * M_PI || ray_angle > 1.5 * M_PI)
					ray->ray_facing_right = 1;
				else
					ray->ray_facing_right = 0;
				if (!ray->ray_facing_right)
					ray->ray_facing_left = 1;
				else
					ray->ray_facing_left = 0;
				ray->distance = 0;
			}

			float	distance_between_points(float p_x, float p_y, float hit_x, float hit_y)
			{
				return (sqrt(((hit_x - p_x) * (hit_x - p_x))
						+ ((hit_y - p_y) * (hit_y - p_y))));
			}

			float	ft_cheking_up(t_ray *ray, float y)
			{
				if (ray->ray_facing_up)
					y--;
				return (y);
			}

			float	ft_cheking_left(t_ray *ray, float x)
			{
				if (ray->ray_facing_left)
					x--;
				return (x);
			}
			"
		initialize.c "
			#include "../cub3d.h"

			void	initialize_data(t_map_data *data)
			{
				data->no_path = NULL;
				data->so_path = NULL;
				data->ea_path = NULL;
				data->we_path = NULL;
				data->c_color = NULL;
				data->f_color = NULL;
				data->map = NULL;
				data->cub_map = NULL;
				data->east = NULL;
				data->west = NULL;
				data->north = NULL;
				data->south = NULL;
			}
			/***** Obtenir map width et map heigth ******/

			void	get_map_h_w(t_cube *cube)
			{
				int		i;
				int		width;

				i = 0;
				width = ft_strlen(cube->map[0]);
				while (cube->map[i])
				{
					if (width < (int)ft_strlen(cube->map[i]))
						width = ft_strlen(cube->map[i]);
					i++;
				}
				cube->map_height = i;
				cube->map_width = width;
			}

			void	initialize_cube(t_cube *cube, t_map_data *data, t_player *player)
			{
				cube->data = data;
				if (data->direction == 'S')
					player->rotation_angle = MATH_PI / 2;
				else if (data->direction == 'N')
					player->rotation_angle = 3 * MATH_PI / 2;
				else if (data->direction == 'W')
					player->rotation_angle = MATH_PI;
				else
					player->rotation_angle = 2 * MATH_PI;
				player->x_position = data->x * PIXEL_SIZE + PIXEL_SIZE / 2;
				player->y_position = data->y * PIXEL_SIZE + PIXEL_SIZE / 2;
				player->radius = 5;
				player->l_r_directions = 0;
				player->b_f_directions = 0;
				player->player_move_speed = 180;
				player->player_rotation_speed = 2 * (MATH_PI / 180);
				cube->player = player;
				cube->map = data->cub_map;
				get_map_h_w(cube);
			}

			int	mlx_initialize(t_cube *cube)
			{
				cube->mlx_win = mlx_init(WIN_WIDTH, WIN_HEIGHT, "Cube3D", false);
				if (!(cube->mlx_win))
				{
					puts(mlx_strerror(mlx_errno));
					return (EXIT_FAILURE);
				}
				cube->image = mlx_new_image(cube->mlx_win, WIN_WIDTH, WIN_HEIGHT);
				if (!(cube->image))
				{
					mlx_close_window(cube->mlx_win);
					puts(mlx_strerror(mlx_errno));
					return (EXIT_FAILURE);
				}
				if (mlx_image_to_window(cube->mlx_win, cube->image, 0, 0) == -1)
				{
					mlx_close_window(cube->mlx_win);
					puts(mlx_strerror(mlx_errno));
					return (EXIT_FAILURE);
				}
				return (EXIT_SUCCESS);
			}

			int	initialize_image(t_cube *cube)
			{
				cube->south = mlx_texture_to_image(cube->mlx_win, cube->data->south);
				cube->east = mlx_texture_to_image(cube->mlx_win, cube->data->east);
				cube->west = mlx_texture_to_image(cube->mlx_win, cube->data->west);
				cube->north = mlx_texture_to_image(cube->mlx_win, cube->data->north);
				textures_delete(cube);
				if (!cube->south || !cube->east || !cube->north || !cube->west)
					return (image_delete(cube), 1);
				if (!mlx_resize_image(cube->south, PIXEL_SIZE, PIXEL_SIZE)
					|| !mlx_resize_image(cube->east, PIXEL_SIZE, PIXEL_SIZE)
					|| !mlx_resize_image(cube->west, PIXEL_SIZE, PIXEL_SIZE)
					|| !mlx_resize_image(cube->north, PIXEL_SIZE, PIXEL_SIZE))
					return (image_delete(cube), 1);
				return (0);
			}
			"
		key_press.c  "
			#include "../cub3d.h"

			void	ft_release(t_cube *cube)
			{
				cube->player->b_f_directions = 0;
				cube->player->l_r_directions = 0;
			}

			void	key_press2(t_cube *cube)
			{
				if (mlx_is_key_down(cube->mlx_win, MLX_KEY_LEFT))
				{
					cube->player->l_r_directions = -1;
					update_player_place(cube);
				}
				if (mlx_is_key_down(cube->mlx_win, MLX_KEY_RIGHT))
				{
					cube->player->l_r_directions = 1;
					update_player_place(cube);
				}
				if (mlx_is_key_down(cube->mlx_win, MLX_KEY_A))
					update_player_place_left(cube);
				if (mlx_is_key_down(cube->mlx_win, MLX_KEY_D))
					update_player_place_right(cube);
			}

			void	key_press(void *param)
			{
				t_cube	*cube;

				cube = (t_cube *)param;
				if (mlx_is_key_down(cube->mlx_win, MLX_KEY_ESCAPE))
					mlx_close_window(cube->mlx_win);
				if (mlx_is_key_down(cube->mlx_win, MLX_KEY_UP)
					|| mlx_is_key_down(cube->mlx_win, MLX_KEY_W))
				{
					cube->player->b_f_directions = 1;
					update_player_place(cube);
				}
				if (mlx_is_key_down(cube->mlx_win, MLX_KEY_DOWN)
					|| mlx_is_key_down(cube->mlx_win, MLX_KEY_S))
				{
					cube->player->b_f_directions = -1;
					update_player_place(cube);
				}
				key_press2(cube);
				clear_image(cube->image);
				cast_rays(cube);
			}
			"
		main.c "
			#include "../cub3d.h"

			int	main(int argc, char **argv)
			{
				t_cube		cube;
				t_player	player;
				t_map_data	data;

				initialize_data(&data);
				ft_parsing(argc, argv, &data);
				initialize_cube(&cube, &data, &player);
				if (mlx_initialize(&cube))
					return (textures_delete(&cube), freemap(data.cub_map), (EXIT_FAILURE));
				if (initialize_image(&cube))
					return (freemap(data.cub_map), 1);
				mlx_loop_hook(cube.mlx_win, key_press, &cube);
				mlx_loop(cube.mlx_win);
				image_delete(&cube);
				mlx_terminate(cube.mlx_win);
				freemap(data.cub_map);
				return (EXIT_SUCCESS);
			}
			"
		player_place.c  "
			include "../cub3d.h"

			int	check_wall(t_cube *cube, float new_x, float new_y)
			{
				int		x;
				int		y;
				int		len;

				x = floor(new_x / PIXEL_SIZE);
				y = floor(new_y / PIXEL_SIZE);
				if (x >= cube->map_width || y >= cube->map_height || x < 0 || y < 0)
					return (0);
				len = ft_strlen(cube->map[y]);
				if (x >= len)
					return (0);
				if (cube->map[y][x] == '1' || cube->map[y][x] == ' ')
					return (0);
				return (1);
			}

			int	arround_player(t_cube *cube, float new_x, float new_y)
			{
				int		i;
				float	x;
				float	y;

				i = 0;
				x = 0;
				y = 0;
				while (i < 360)
				{
					x = new_x + cos(i * MATH_PI / 180) * 200;
					y = new_y + sin(i * MATH_PI / 180) * 200;
					if (!check_wall(cube, x, y) || !check_wall(cube, new_x, new_y))
						break ;
					i++;
				}
				if (i != 360)
					return (0);
				return (1);
			}

			void	update_player_place(t_cube *cube)
			{
				int		move_step;
				float	new_x;
				float	new_y;

				move_step = 0;
				new_x = 0;
				new_y = 0;
				cube->player->rotation_angle += cube->player->player_rotation_speed
					* cube->player->l_r_directions;
				cube->player->rotation_angle = ft_periodic(cube->player->rotation_angle);
				move_step = cube->player->b_f_directions * cube->player->player_move_speed;
				new_x = cube->player->x_position + cos(cube->player->rotation_angle)
					* move_step;
				new_y = cube->player->y_position + sin(cube->player->rotation_angle)
					* move_step;
				if (arround_player(cube, new_x, new_y))
				{
					cube->player->x_position = new_x;
					cube->player->y_position = new_y;
				}
				ft_release(cube);
			}

			void	update_player_place_left(t_cube *cube)
			{
				float	new_x;
				float	new_y;

				new_x = cube->player->x_position
					+ cos(cube->player->rotation_angle - M_PI / 2)
					* cube->player->player_move_speed;
				new_y = cube->player->y_position
					+ sin(cube->player->rotation_angle - M_PI / 2)
					* cube->player->player_move_speed;
				if (arround_player(cube, new_x, new_y))
				{
					cube->player->x_position = new_x;
					cube->player->y_position = new_y;
				}
				ft_release(cube);
			}

			void	update_player_place_right(t_cube *cube)
			{
				float	new_x;
				float	new_y;

				new_x = cube->player->x_position
					+ cos(cube->player->rotation_angle + M_PI / 2)
					* cube->player->player_move_speed;
				new_y = cube->player->y_position
					+ sin(cube->player->rotation_angle + M_PI / 2)
					* cube->player->player_move_speed;
				if (arround_player(cube, new_x, new_y))
				{
					cube->player->x_position = new_x;
					cube->player->y_position = new_y;
				}
				ft_release(cube);
			}
			"
		ray_casting_helper.c "
			#include "../cub3d.h"

			void	get_distance(t_ray *ray, int hit_wall, t_cube *cube)
			{
				if (hit_wall)
					ray->distance = distance_between_points(cube->player->x_position,
							cube->player->y_position, ray->wall_hit_x, ray->wall_hit_y);
				else
					ray->distance = INT_MAX;
			}

			void	check_for_h(t_ray *ray, float x_intercept, float y_intercept,
					t_cube *cube)
			{
				float	next_hor_x;
				float	next_hor_y;
				int		hit_wall;

				next_hor_x = x_intercept;
				next_hor_y = y_intercept;
				hit_wall = 0;
				while (next_hor_x >= 0 && next_hor_y >= 0
					&& next_hor_x < cube->map_width * PIXEL_SIZE
					&& next_hor_y < cube->map_height * PIXEL_SIZE)
				{
					if (!check_wall(cube, next_hor_x, ft_cheking_up(ray, next_hor_y)))
					{
						ray->wall_hit_x = next_hor_x;
						ray->wall_hit_y = next_hor_y;
						hit_wall = 1;
						break ;
					}
					else
					{
						next_hor_x += ray->x_step;
						next_hor_y += ray->y_step;
					}
				}
				get_distance(ray, hit_wall, cube);
			}

			void	check_for_v(t_ray *ray, float x_intercept, float y_intercept,
					t_cube *cube)
			{
				float	next_ver_x;
				float	next_ver_y;
				int		hit_wall;

				next_ver_x = x_intercept;
				next_ver_y = y_intercept;
				hit_wall = 0;
				while (next_ver_x >= 0 && next_ver_y >= 0
					&& next_ver_x <= cube->map_width * PIXEL_SIZE
					&& next_ver_y <= cube->map_height * PIXEL_SIZE)
				{
					if (!check_wall(cube, ft_cheking_left(ray, next_ver_x), next_ver_y))
					{
						ray->wall_hit_x = next_ver_x;
						ray->wall_hit_y = next_ver_y;
						hit_wall = 1;
						break ;
					}
					else
					{
						next_ver_x += ray->x_step;
						next_ver_y += ray->y_step;
					}
				}
				get_distance(ray, hit_wall, cube);
			}

			/* HORIZONTAL RAY INTERSECTION CODE */
			/* FIND THE Y COORDINATE OF THE CLOSEST HORIZONTAL GRID INTERSECTION */
			/* FIND THE X COORDINATE OF THE CLOSEST HORIZONTAL GRID INTERSECTION */
			/* CALCULATE THE INCREMENT X_STEP AND THE Y_STEP */

			void	horizontal_ray(t_ray *ray, float ray_angle, t_cube *cube)
			{
				float	y_intercept;
				float	x_intercept;

				initialize_tray(ray, ray_angle);
				y_intercept = floor(cube->player->y_position / PIXEL_SIZE) * PIXEL_SIZE;
				if (ray->ray_facing_down)
					y_intercept += PIXEL_SIZE;
				x_intercept = cube->player->x_position
					+ (y_intercept - cube->player->y_position) / tan(ray_angle);
				ray->y_step = PIXEL_SIZE;
				if (ray->ray_facing_up)
					ray->y_step *= -1;
				ray->x_step = PIXEL_SIZE / tan(ray_angle);
				if (ray->ray_facing_left && ray->x_step > 0)
					ray->x_step *= -1;
				else if (ray->ray_facing_right && ray->x_step < 0)
					ray->x_step *= -1;
				check_for_h(ray, x_intercept, y_intercept, cube);
			}
			/*VERTICAL RAY INTERSECTION CODE */
			/* FIND THE X COORDINATE OF THE CLOSEST VERTICAL GRID INTERSECTION */
			/* FIND THE Y COORDINATE OF THE CLOSEST VERTICAL GRID INTERSECTION */
			/* CALCULATE THE INCREMENT X_STEP AND Y_STEP */

			void	vertical_ray(t_ray *ray, float ray_angle, t_cube *cube)
			{
				float	y_intercept;
				float	x_intercept;

				initialize_tray(ray, ray_angle);
				x_intercept = floor(cube->player->x_position / PIXEL_SIZE) * PIXEL_SIZE;
				if (ray->ray_facing_right)
					x_intercept += PIXEL_SIZE;
				y_intercept = cube->player->y_position
					+ (x_intercept - cube->player->x_position) * tan(ray_angle);
				ray->x_step = PIXEL_SIZE;
				if (ray->ray_facing_left)
					ray->x_step *= -1;
				ray->y_step = PIXEL_SIZE * tan(ray_angle);
				if (ray->ray_facing_up && ray->y_step > 0)
					ray->y_step *= -1;
				else if (ray->ray_facing_down && ray->y_step < 0)
					ray->y_step *= -1;
				check_for_v(ray, x_intercept, y_intercept, cube);
			}
			"
		ray_casting.c "
			#include "../cub3d.h"

			void	get_final_ray_cordonate(t_ray *final_ray, t_ray *ray_v_or_h)
			{
				final_ray->ray_angle = ray_v_or_h->ray_angle;
				final_ray->wall_hit_x = ray_v_or_h->wall_hit_x;
				final_ray->wall_hit_y = ray_v_or_h->wall_hit_y;
				final_ray->distance = ray_v_or_h->distance;
				final_ray->ray_facing_down = ray_v_or_h->ray_facing_down;
				final_ray->ray_facing_up = ray_v_or_h->ray_facing_up;
				final_ray->ray_facing_left = ray_v_or_h->ray_facing_left;
				final_ray->ray_facing_right = ray_v_or_h->ray_facing_right;
			}

			void	cast_the_ray(t_cube *cube, float ray_angle, int i)
			{
				t_ray	ray_horizontal;
				t_ray	ray_vertical;
				t_ray	final_ray;

				horizontal_ray(&ray_horizontal, ray_angle, cube);
				vertical_ray(&ray_vertical, ray_angle, cube);
				if (ray_horizontal.distance < ray_vertical.distance)
				{
					get_final_ray_cordonate(&final_ray, &ray_horizontal);
					final_ray.is_ver = 0;
				}
				else
				{
					get_final_ray_cordonate(&final_ray, &ray_vertical);
					final_ray.is_ver = 1;
				}
				render_wall(&final_ray, cube, i);
			}

			void	cast_rays(t_cube *cube)
			{
				float	ray_angle;
				float	limit_angle;
				int		i;

				i = 0;
				ray_angle = cube->player->rotation_angle - (FOV / 2);
				ray_angle = ft_periodic(ray_angle);
				limit_angle = cube->player->rotation_angle + (FOV / 2);
				limit_angle = ft_periodic(limit_angle);
				while (i < WIN_WIDTH)
				{
					ray_angle = ft_periodic(ray_angle);
					cast_the_ray(cube, ray_angle, i);
					ray_angle += FOV / WIN_WIDTH;
					i++;
				}
			}
			"
		render_walls.c "
			#include "../cub3d.h"

			void	ft_getoff_x(t_cube *cube, t_ray *ray)
			{
				if (ray->is_ver)
					cube->player->offset_x = (int)ray->wall_hit_y % PIXEL_SIZE;
				else
					cube->player->offset_x = (int)ray->wall_hit_x % PIXEL_SIZE;
			}

			void	draw_ceiling(t_cube *cube, int x, int wall_top)
			{
				int	y;

				y = -1;
				while (++y < wall_top)
					mlx_put_pixel(cube->image, x, y, ft_pixel(cube->data->carr[0],
							cube->data->carr[1], cube->data->carr[2], 255));
			}

			void	draw_floor(t_cube *cube, int x, int wall_bottom)
			{
				int	y;

				y = wall_bottom - 1;
				while (++y < WIN_HEIGHT)
					mlx_put_pixel(cube->image, x, y, ft_pixel(cube->data->farr[0],
							cube->data->farr[1], cube->data->farr[2], 2555));
			}

			void	get_colors_w_e(t_ray *ray, t_cube *cube, int j)
			{
				if (ray->is_ver)
				{
					if (ray->ray_facing_left)
					{
						ray->colors.r = cube->west->pixels[j];
						ray->colors.g = cube->west->pixels[j + 1];
						ray->colors.b = cube->west->pixels[j + 2];
						ray->colors.a = cube->west->pixels[j + 3];
					}
					else
					{
						ray->colors.r = cube->east->pixels[j];
						ray->colors.g = cube->east->pixels[j + 1];
						ray->colors.b = cube->east->pixels[j + 2];
						ray->colors.a = cube->east->pixels[j + 3];
					}
				}
			}

			void	get_colors_n_s(t_ray *ray, t_cube *cube, int j)
			{
				if (!ray->is_ver)
				{
					if (ray->ray_facing_down)
					{
						ray->colors.r = cube->south->pixels[j];
						ray->colors.g = cube->south->pixels[j + 1];
						ray->colors.b = cube->south->pixels[j + 2];
						ray->colors.a = cube->south->pixels[j + 3];
					}
					else
					{
						ray->colors.r = cube->north->pixels[j];
						ray->colors.g = cube->north->pixels[j + 1];
						ray->colors.b = cube->north->pixels[j + 2];
						ray->colors.a = cube->north->pixels[j + 3];
					}
				}
			}
			// Calculate the distance to the projection plane /*Project wall height*/
			/*Calculate the top and bottom of the wall strip*/
			/*Calculate the top and bottom of the wall strip*/

			void	calculate_wall_height(t_ray *ray, t_cube *cube)
			{
				ray->raydistance = ray->distance * cos(ft_periodic(ray->ray_angle)
						- cube->player->rotation_angle);
				ray->distance_project = (WIN_WIDTH / 2) / tan(FOV / 2);
				ray->wall_striph = (PIXEL_SIZE / ray->raydistance) * ray->distance_project;
				ray->wall_top = (WIN_HEIGHT / 2) - (ray->wall_striph / 2);
				ray->wall_bottom = (WIN_HEIGHT / 2) + (ray->wall_striph / 2);
			}

			void	render_wall(t_ray *ray, t_cube *cube, int i)
			{
				int	y;
				int	dis;
				int	j;

				calculate_wall_height(ray, cube);
				draw_ceiling(cube, i, ray->wall_top);
				if (ray->wall_top < 0)
					ray->wall_top = 0;
				if (ray->wall_bottom >= WIN_HEIGHT)
					ray->wall_bottom = WIN_HEIGHT - 1;
				ft_getoff_x(cube, ray);
				y = ray->wall_top;
				while (y < ray->wall_bottom)
				{
					dis = y - WIN_HEIGHT / 2 + ray->wall_striph / 2;
					cube->player->offset_y = dis * ((float)PIXEL_SIZE / ray->wall_striph);
					j = (cube->player->offset_x + cube->player->offset_y * PIXEL_SIZE) * 4;
					get_colors_w_e(ray, cube, j);
					get_colors_n_s(ray, cube, j);
					mlx_put_pixel(cube->image, i, y, ft_pixel(ray->colors.r, ray->colors.g,
							ray->colors.b, ray->colors.a * exp(-0.00007 * ray->distance)));
					y++;
				}
				draw_floor(cube, i, ray->wall_bottom);
			}

			"
		texture_image.c "
			#include "../cub3d.h"

			int	ft_pixel(int r, int g, int b, int a)
			{
				return (r << 24 | g << 16 | b << 8 | a);
			}

			void	clear_image(mlx_image_t *image)
			{
				int		x;
				int		y;

				x = 0;
				y = 0;
				while (y < WIN_HEIGHT)
				{
					x = 0;
					while (x < WIN_WIDTH)
					{
						mlx_put_pixel(image, x, y, ft_pixel(0, 0, 0, 0));
						x++;
					}
					y++;
				}
			}

			void	textures_delete(t_cube *cube)
			{
				if (cube->data->south)
					mlx_delete_texture(cube->data->south);
				if (cube->data->east)
					mlx_delete_texture(cube->data->east);
				if (cube->data->west)
					mlx_delete_texture(cube->data->west);
				if (cube->data->north)
					mlx_delete_texture(cube->data->north);
			}

			void	image_delete(t_cube *cube)
			{
				if (cube->south && cube->mlx_win)
				{
					mlx_delete_image(cube->mlx_win, cube->south);
					cube->south = NULL;
				}
				if (cube->east && cube->mlx_win)
				{
					mlx_delete_image(cube->mlx_win, cube->east);
					cube->east = NULL;
				}
				if (cube->west && cube->mlx_win)
				{
					mlx_delete_image(cube->mlx_win, cube->west);
					cube->west = NULL;
				}
				if (cube->north && cube->mlx_win)
				{
					mlx_delete_image(cube->mlx_win, cube->north);
					cube->north = NULL;
				}
			}

			"
		cub3d.h "
		
			#ifndef CUB3D_H
			# define CUB3D_H
			
			# include "../MLXlib42/MLX42.h"
			# include "./parsing/get_next_line.h"
			# include "../libft/libft.h"
			# include <unistd.h>
			# include <stdlib.h>
			# include <fcntl.h>
			# include <stdbool.h>
			# include <stdio.h>
			# include <math.h>
			# include <limits.h>
			
			# define PIXEL_SIZE 1024
			# define WIN_WIDTH 1900
			# define WIN_HEIGHT 1080
			# define MATH_PI 3.14159265358979323846
			# define FOV	1.0472
			
			// Parsing
			typedef struct s_pars_info
			{
				bool	north;
				bool	south;
				bool	east;
				bool	west;
				bool	floor;
				bool	ceiling;
			}	t_pars_info;
			
			typedef struct s_map_data
			{
				char			*f_color;
				char			*c_color;
				char			*no_path;
				char			*so_path;
				char			*we_path;
				char			*ea_path;
				char			**map;
				char			**cub_map;
				char			direction;
				int				h;
				int				w;
				int				x;
				int				y;
				int				farr[3];
				int				carr[3];
				mlx_texture_t	*north;
				mlx_texture_t	*south;
				mlx_texture_t	*east;
				mlx_texture_t	*west;
				mlx_texture_t	textures[4];
				t_pars_info		info;
			}	t_map_data;
			
			// Errors
			void	freedata(t_map_data *data);
			void	freemap(char **map);
			void	err_exit(char *s);
			int		parsmap(t_map_data *data);
			int		gettexters(t_map_data *data, char *line, char *dir);
			int		parscolors(t_map_data *data);
			int		parsdirections(t_map_data *data);
			int		parsinfos(t_map_data *data);
			int		parsmap(t_map_data *data);
			int		checkafternewline(char *line);
			int		parslinemap(char *map);
			char	*getlinemap(char **map);
			char	**findthemap(char **data);
			int		parsborders(t_map_data *data, int i, int j, char c);
			void	ft_parsing(int argc, char **argv, t_map_data *data);
			
			// Player
			typedef struct s_player
			{
				float	x_position;
				float	y_position;
				int		radius;
				int		l_r_directions;
				int		b_f_directions;
				float	rotation_angle;
				int		player_move_speed;
				float	player_rotation_speed;
				int		offset_x;
				int		offset_y;
				float	key_a;
				float	key_d;
			}	t_player;
			
			// Colors
			typedef struct s_colors
			{
				int	r;
				int	g;
				int	b;
				int	a;
			}	t_colors;
			
			// Cube
			typedef struct s_cube
			{
				t_player		*player;
				mlx_t			*mlx_win;
				mlx_image_t		*mini_map;
				mlx_image_t		*image;
				char			**map;
				mlx_texture_t	*test;
				mlx_image_t		*east;
				mlx_image_t		*west;
				mlx_image_t		*north;
				mlx_image_t		*south;
				int				map_height;
				int				map_width;
				t_map_data		*data;
				mlx_image_t		*frame;
				int				mouse_x;
				int				mouse_y;
				mlx_texture_t	*t_door;
				mlx_image_t		*i_door;
				mlx_texture_t	*texture[4];
			}	t_cube;
			
			// Ray
			typedef struct s_ray
			{
				float		ray_angle;
				float		wall_hit_x;
				float		wall_hit_y;
				float		distance;
				int			ray_facing_down;
				int			ray_facing_up;
				int			ray_facing_right;
				int			ray_facing_left;
				float		x_step;
				float		y_step;
				int			is_ver;
				int			wall_striph;
				float		raydistance;
				float		distance_project;
				float		wall_top;
				float		wall_bottom;
				t_colors	colors;
			}	t_ray;
			
			// Function prototypes
			void	initialize_data(t_map_data *data);
			void	initialize_cube(t_cube *cube, t_map_data *data, t_player *player);
			void	animation(void *input);
			void	cast_rays(t_cube *cube);
			int		ft_pixel(int r, int g, int b, int a);
			float	ft_periodic(float angle);
			int		check_wall(t_cube *cube, float new_x, float new_y);
			void	draw_line(t_cube *cube);
			void	render_wall(t_ray *ray, t_cube *cube, int i);
			void	display_map(t_cube *cube);
			void	update_player_place(t_cube *cube);
			void	update_player_place_right(t_cube *cube);
			void	update_player_place_left(t_cube *cube);
			int		mlx_initialize(t_cube *cube);
			int		initialize_image(t_cube *cube);
			void	clear_image(mlx_image_t *image);
			void	key_press(void *param);
			void	ft_release(t_cube *cube);
			void	textures_delete(t_cube *cube);
			void	image_delete(t_cube *cube);
			void	ft_getoff_x(t_cube *cube, t_ray *ray);
			void	draw_ceiling(t_cube *cube, int x, int wall_top);
			void	draw_floor(t_cube *cube, int x, int wall_bottom);
			float	distance_between_points(float p_x, float p_y, float hit_x, float hit_y);
			float	ft_cheking_up(t_ray *ray, float y);
			float	ft_cheking_left(t_ray *ray, float x);
			void	initialize_tray(t_ray *ray, float ray_angle);
			void	check_for_v(t_ray *ray, float x_intercept, float y_intercept,
						t_cube *cube);
			void	check_for_h(t_ray *ray, float x_intercept, float y_intercept,
						t_cube *cube);
			void	horizontal_ray(t_ray *ray, float ray_angle, t_cube *cube);
			void	vertical_ray(t_ray *ray, float ray_angle, t_cube *cube);
			void	get_distance(t_ray *ray, int hit_wall, t_cube *cube);
			
			#endif
			"